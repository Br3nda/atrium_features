<?php

include_once('atrium.features.inc');

/**
 * Users may view all members of the site.
 */
define('ATRIUM_MEMBERS_ALL', 0);

/**
 * Users may only view members that belong to their groups.
 */
define('ATRIUM_MEMBERS_GROUP', 1);

/**
 * Implementation of hook_user_default_permissions_alter().
 */
function atrium_user_default_permissions_alter(&$permissions) {
  if (!variable_get('user_register', FALSE)) {
    $access_perms = array(
      'access user profiles' => array(
        'name' => 'access user profiles',
        'roles' => array('authenticated user'),
      ),
      'access content' => array(
        'name' => 'access content',
        'roles' => array('authenticated user'),
      ),
      'access comments' => array(
        'name' => 'access comments',
        'roles' => array('authenticated user'),
      ),
      'view revisions' => array(
        'name' => 'view revisions',
        'roles' => array('authenticated user'),
      ),
    );
  }
  else {
    $access_perms = array(
      'access user profiles' => array(
        'name' => 'access user profiles',
        'roles' => array('anonymous user', 'authenticated user'),
      ),
      'access content' => array(
        'name' => 'access content',
        'roles' => array('anonymous user', 'authenticated user'),
      ),
      'access comments' => array(
        'name' => 'access comments',
        'roles' => array('anonymous user', 'authenticated user'),
      ),
      'view revisions' => array(
        'name' => 'view revisions',
        'roles' => array('anonymous user', 'authenticated user'),
      ),
    );
  }
  switch (variable_get('atrium_members', ATRIUM_MEMBERS_GROUP)) {
    case ATRIUM_MEMBERS_ALL:
      $access_perms['view users outside groups'] = array(
        'name' => 'view users outside groups',
        'roles' => array('anonymous user', 'authenticated user', 'manager', 'admin'),
      );
      break;
    case ATRIUM_MEMBERS_GROUP:
      $access_perms['view users outside groups'] = array(
        'name' => 'view users outside groups',
        'roles' => array('manager', 'admin'),
      );
      break;
  }
  // Only alter if this alter is running for our perms.
  foreach ($permissions as $k => $permission) {
    if (isset($access_perms[$permission['name']])) {
      $permissions[$k] = $access_perms[$permission['name']];
    }
  }
}

/**
 * Implementation of hook_init().
 */
function atrium_init() {
  // Alert the user that they are browsing an archived group.
  $space = spaces_get_space();
  if ($space && atrium_is_archived($space)) {
    $message = t('This !type is <strong>archived</strong>. You may not add or alter any of its content.', array('!type' => node_get_types('name', 'group')));
    if (node_access('update', $space->group)) {
      $message .= ' '. t('To reactivate this !type, !link.', array('!type' => node_get_types('name', 'group'), '!link' => l(t('click here'), "node/$space->id/reactivate")));
    }
    drupal_set_message($message);
  }
}

/**
 * Implementation of hook_menu().
 */
function atrium_menu() {
  $items = array();
  $items['welcome'] = array(
    'title' => 'Welcome',
    'description' => 'Custom login page.',
    'page callback' => 'atrium_welcome',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'atrium.pages.inc',
  );
  $items['help'] = array(
    'title' => 'Help',
    'description' => 'Information and help about using the site.',
    'page callback' => 'atrium_help_page',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'atrium.pages.inc',
  );
  $items['node/%node/reactivate'] = array(
    'title' => 'Reactivate',
    'description' => 'Reactivate confirmation for unpublished nodes.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('atrium_reactivate', 1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'type' => MENU_CALLBACK,
    'file' => 'atrium.pages.inc',
  );
  return $items;
}

/**
 * Implementation of hook_menu_alter().
 */
function atrium_menu_alter(&$callbacks) {
  // Replace search callbacks
  if (module_exists('search')) {
    $unset = array('search', 'search/node/%menu_tail', 'search/user/%menu_tail');
    foreach ($unset as $path) {
      if (!empty($callbacks[$path])  && $callbacks[$path]['module'] == 'search') {
        unset($callbacks[$path]);
      }
    }
  }

  // Replace taxonomy autocomplete with our own space-aware autocomplete
  if (module_exists('taxonomy')) {
    $callbacks['taxonomy/autocomplete']['page callback'] = 'atrium_taxonomy_autocomplete';
    $callbacks['taxonomy/autocomplete']['module'] = 'atrium';
    $callbacks['taxonomy/autocomplete']['file'] = 'atrium.pages.inc';
  }

  // @TODO Replace user autocomplete with space-aware / "user access" aware autocomplete

  // Hijack the /node callback for use as our welcome page
  $callbacks['node']['page callback'] = 'drupal_goto';
  $callbacks['node']['page arguments'] = array('welcome');

  // Kill undesirable menu items
  $yank = array(
    'book',
    'rss.xml',
    'node/%node/outline',
  );
  foreach ($yank as $path) {
    if (!empty($items[$path])) {
      unset($items[$path]);
    }
  }

  // Replace default 403
  $items['access-denied']['page callback'] = 'atrium_403';
  $items['access-denied']['module'] = 'atrium';
  $items['access-denied']['file'] = 'atrium.pages.inc';
}

/**
 * Implementation of hook_block().
 */
function atrium_block($op = 'list', $delta = 0) {
  switch ($op) {
    case 'list':
      return array(
        'account' => array('info' => t('Atrium: User account')),
        'admin_links' => array('info' => t('Atrium: Admin links')),
        'book' => array('info' => t('Atrium: Book')),
        'create' => array('info' => t('Atrium: Create content')),
        'search' => array('info' => t('Atrium: Search form')),
        'user_links' => array('info' => t('Atrium: User links')),
      );
    case 'view':
      module_load_include('inc', 'atrium', 'atrium.block');
      $function = "_atrium_block_{$delta}";
      if (function_exists($function)) {
        return call_user_func($function);
      }
      break;
  }
}

/**
 * Implementation of hook_form_alter().
 */
function atrium_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    // Set login layout via context
    case 'user_login':
    case 'user_pass':
    case 'user_register':
      context_set('context', 'layout_login', context_load('layout_login'));
      break;
    // Form alter handling via callbacks
    case 'spaces_features_form':
    case 'system_themes_form':
    case 'node_type_form':
    case 'views_exposed_form':
      module_load_include('inc', 'atrium', 'atrium.pages');
      $function = "_atrium_form_{$form_id}_alter";
      if (function_exists($function)) {
        $function($form, $form_state);
      }
      break;
  }

  //  Crappy exception for node form.
  if ($form['#id'] == 'node-form') {
    module_load_include('inc', 'atrium', 'atrium.pages');
    $function = "_atrium_form_node_form_alter";
    if (function_exists($function)) {
      $function($form, $form_state);
    }
  }

  // Disable notifications when editing a post outside of a group space
  if ((!empty($form['#node']) || $form_id == 'comment_form') && isset($form['notifications'])) {
    $space = spaces_get_space();
    if (empty($space) || $space->type != 'og') {
      $form['notifications']['#access'] = FALSE;
    }
  }
}

/**
 * Implementation of hook_link_alter().
 */
function atrium_link_alter(&$links, $node) {
  if (!empty($links['comment_new_comments']) && !empty($links['comment_comments'])) {
    unset($links['comment_comments']);
  }
}

/**
 * Implementation of hook_litenode().
 */
function atrium_litenode() {
  $info = array();
  $info['atrium'] = array();
  $info['atrium']['module'] = t('Atrium');
  $info['atrium']['map'] = array();
  $info['atrium']['fields'] = array(
    'timestamp_1' => array(
      'id' => 'timestamp_1',
      'table' => 'history_user',
      'field' => 'timestamp',
    ),
  );
  return $info;
}

/**
 * Implementation of hook_litenode_alter().
 */
function atrium_litenode_alter(&$node, $row) {
  $node->new = atrium_get_readstate($row->history_user_timestamp, $node->changed);
}

/**
 * Implemenation of hook_nodeapi().
 */
function atrium_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch ($op) {
    case 'prepare':
    case 'view':
      // Load the node's read state.
      if ($op === 'view' && !isset($node->new)) {
        global $user;
        $readtime = db_result(db_query("SELECT timestamp FROM {history} WHERE uid = %d AND nid = %d", $user->uid, $node->nid));
        $node->new = atrium_get_readstate($readtime, $node->changed);
      }

      // Confirm we are actually on a page of relevance
      if (menu_get_object() === $node) {
        // Set the context for the root book node type when on a book child page
        if (!empty($node->book['bid'])) {
          $type = db_result(db_query("SELECT type FROM {node} WHERE nid = %d", $node->book['bid']));

          // @TODO: Write a condition plugin for this rather than using nodeapi.
          if ($plugin = context_get_plugin('condition', 'node')) {
            $plugin->execute($node, 'view');
          }
        }
        // Display a message for archived content
        if ($op == 'view' && $node->status == 0) {
          $message = t('This !type is <strong>archived</strong>.', array('!type' => node_get_types('name', $node->type)));
          if (node_access('update', $node)) {
            $message .= ' '. t('To reactivate this !type, !link.', array('!type' => node_get_types('name', $node->type), '!link' => l(t('click here'), "node/{$node->nid}/reactivate")));
          }
          drupal_set_message($message);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_context_links_alter();
 */
function atrium_context_links_alter(&$links) {
  if (context_get('context', 'spaces-feature-book') && isset($links['book']) && $space = spaces_get_space()) {
    $item = menu_get_item('node/add/book');
    $node = menu_get_object();
    if ($item['access'] && !empty($node->book['mlid'])) {
      $links['book']['query'] = "parent={$node->book['mlid']}";
    }
  }
}

/**
 * Implementation of hook_context_default_contexts_alter().
 */
function atrium_context_default_contexts_alter(&$contexts) {
  if (module_exists('spaces_dashboard')) {
    $contexts['spaces_dashboard']->reactions['block']['blocks'] = array(
      'views-atrium_intranet-block_3' => array(
        'module' => 'views',
        'delta' => 'atrium_intranet-block_3',
        'region' => 'content',
        'weight' => 0,
      ),
      'views-atrium_groups-block_2' => array(
        'module' => 'views',
        'delta' => 'atrium_groups-block_2',
        'region' => 'right',
        'weight' => 0,
      ),
    );
  }
  // Conditionally add the notifications UI subscription block.
  if (module_exists('notifications_ui') && !empty($contexts['atrium-intranet-global'])) {
    $contexts['atrium-intranet-global']->reactions['block']['blocks']['notifications_ui_0'] = array(
      'module' => 'notifications_ui',
      'delta' => '0',
      'weight' => 48,
      'region' => 'page_tools',
    );
  }
}

/**
 * Implementation of hook_views_api().
 */
function atrium_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'atrium') .'/includes',
  );
}

/**
 * Implementation of preprocess_views_view().
 */
function atrium_preprocess_views_view(&$vars) {
  $view = $vars['view'];
  $map = spaces_features_map();
  $feature = isset($map['views'][$view->name]) ? $map['views'][$view->name] : NULL;
  if ($feature && strpos($view->current_display, 'page') !== FALSE && empty($view->result) && empty($vars['empty'])) {
    if ($type = array_search($feature, $map['node'])) {
      $item = menu_get_item('node/add/'. strtr($type, array('_' => '-')));
      if ($item && $item['access']) {
        $output = t('Please add your first @type to get started.', array('@type' => node_get_types('name', $type)));
        $output .= "<div class='buttons'>". theme('links', context_links()) ."</div>";
      }
    }
    $vars['empty'] = !empty($output) ? $output : t('There is currently no content to view in this section.');
  }
}

/**
 * API Functions ======================================================

 */
/**
 * Generates an array of account links suitable for use in theme_links().
 */
function atrium_account_links() {
  global $user;
  $links = array();

  // @TODO: If menu.inc had a real API function for this we would use it, but
  // as of now we'd have a copy hand paste hack job of menu_local_tasks()...
  $paths = array(
    "user/{$user->uid}/edit" => t('Account settings'),
    "user/{$user->uid}/groups" => '',
    "user/{$user->uid}/notifications" => '',
    "user/{$user->uid}/openid" => '',
    'logout' => '',
  );
  foreach ($paths as $path => $title) {
    $item = menu_get_item($path);
    if ($item && $item['access']) {
      $class = seed_id_safe($item['href']);
      $links[$class] = array(
        'title' => !empty($title) ? $title : $item['title'],
        'href' => $item['href'],
      );
    }
  }
  drupal_alter('atrium_account_links', $links, $space);
  return $links;
}

/**
 * Generates an array of admin links for the current space suitable
 * for use in theme_links().
 */
function atrium_admin_links($space = NULL) {
  $links = array();
  $space = !isset($space) ? spaces_get_space() : $space;

  // Within a space
  if ($space) {
    if ($space->type == 'og' && $space->access_admin()) {
      $item = menu_get_item("og/users/{$space->id}/faces");
      if ($item && $item['access']) {
        $links['members'] = array(
          'title' => t('Members'),
          'href' => "og/users/{$space->id}/faces",
        );
      }

      $item = menu_get_item("node/{$space->sid}/edit");
      if ($item && $item['access']) {
        // Add settings link for administering spaces
        $links['settings'] = array(
          'title' => t('@type settings', array('@type' => node_get_types('name', $space->group->type))),
          'href' => "node/{$space->id}/edit",
        );
      }

      $item = menu_get_item("node/{$space->id}/features");
      if ($item && $item['access']) {
        $links['features'] = array(
          'title' => t('Customize features'),
          'href' => "node/{$space->id}/features",
        );
      }
    }
  }
  // Sitewide
  else if (user_access('administer site configuration')) {
    $links['features'] = array(
      'title' => t('Customize features'),
      'href' => "features",
    );
  }
  drupal_alter('atrium_admin_links', $links, $space);
  return $links;
}

/**
 * Generates an array of user links for the current space suitable
 * for use in theme_links().
 */
function atrium_user_links($space = NULL) {
  $space = !isset($space) ? spaces_get_space() : $space;
  if ($space && $space->type == 'og' && $space->access_space()) {
    // TODO revist this
    if ($subscribe = spaces_og_subscription_link()) {
      $links['subscribe'] = $subscribe;
    }
    drupal_alter('atrium_user_links', $links, $space);
    return $links;
  }
  return array();
}

/**
 * Abstracts the node types provided in update streams/feed views.
 */
function atrium_update_types($reset = FALSE) {
  static $types;
  if (!isset($types) || $reset) {
    $types = array();
    foreach (array_keys(node_get_types()) as $type) {
      if (variable_get('atrium_update_type_'. $type, TRUE)) {
        $types[] = $type;
      }
    }
  }
  return $types;
}

/**
 * Wrapper access callback to provide access check against both a spaces
 * feature and an access perm.
 */
function atrium_feature_access($feature, $perm = 'access content') {
  return spaces_access_feature('view', $feature) && user_access($perm);
}

/**
 * Function that checks whether a group has been archived.
 */
function atrium_is_archived($space = NULL) {
  switch ($space->type) {
    case 'og':
      return !$space->group->status;
  }
  return FALSE;
}

/**
 * Helper function to deal with node read state logic.
 */
function atrium_get_readstate($readtime, $nodetime) {
  if ($readtime == 0 && $nodetime > NODE_NEW_LIMIT) {
    return MARK_NEW;
  }
  elseif ($nodetime > $readtime && $nodetime > NODE_NEW_LIMIT) {
    return MARK_UPDATED;
  }
  return MARK_READ;
}

/**
 * Search form.
 */
function atrium_search_form($form_state) {
  if (arg(0) == 'search' && isset($_GET['keys'])) {
    $default = urldecode($_GET['keys']);
  }
  $search = 
  $form = array();
  $form['search'] = array(
    '#type' => 'textfield',
    '#size' => 30,
    '#required' => true,
    '#default_value' => !empty($default) ? $default : '',
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
    '#submit' => array('atrium_search_form_submit'),
  );
  return $form;
}

/**
 * Search form submit handler.
 */
function atrium_search_form_submit($form, &$form_state) {
  $search = $form_state['values']['search'];
  drupal_goto('search', array('keys' => $search));
}

/**
 * Form submit handlers ===============================================
 */

/**
 * Reactivate node submit handler.
 */
function atrium_reactivate_submit($form, &$form_state) {
  $nid = $form_state['values']['nid'];
  $node = node_load($nid);
  $node->status = 1;
  node_save($node);
  drupal_set_message(t('The @type @title has been reactivated.', array('@type' => node_get_types('name', $node->type), '@title' => $node->title)));
  purl_goto('<front>', array('purl' => array('provider' => 'spaces_og', 'id' => $nid)));
}

/**
 * OG archive submit handler.
 */
function atrium_archive_submit($form, &$form_state) {
  $nid = $form_state['values']['nid'];
  $node = node_load($nid);
  $node->status = 0;
  node_save($node);
  drupal_set_message(t('The @type @title has been archived.', array('@type' => node_get_types('name', $node->type), '@title' => $node->title)));
  purl_goto('<front>', array('purl' => array('provider' => 'spaces_og', 'id' => $nid)));
}

/**
 * Trigger a features rebuild.
 */
function atrium_form_spaces_features_form_submit(&$form, &$form_state) {
  features_rebuild();
}
