<?php

include_once('atrium.features.inc');

/**
 * Users may view all members of the site.
 */
define('ATRIUM_MEMBERS_ALL', 0);

/**
 * Users may only view members that belong to their groups.
 */
define('ATRIUM_MEMBERS_GROUP', 1);

/**
 * Implementation of hook_user_default_permissions().
 */
function atrium_user_default_permissions() {
  $permissions = array();

  if (!variable_get('user_register', FALSE)) {
    $permissions[] = array(
      'name' => 'access user profiles',
      'roles' => array('authenticated user'),
    );
    $permissions[] = array(
      'name' => 'access content',
      'roles' => array('authenticated user'),
    );
    $permissions[] = array(
      'name' => 'access comments',
      'roles' => array('authenticated user'),
    );
    $permissions[] = array(
      'name' => 'view revisions',
      'roles' => array('authenticated user'),
    );
  }
  else {
    $permissions[] = array(
      'name' => 'access user profiles',
      'roles' => array('anonymous user', 'authenticated user'),
    );
    $permissions[] = array(
      'name' => 'access content',
      'roles' => array('anonymous user', 'authenticated user'),
    );
    $permissions[] = array(
      'name' => 'access comments',
      'roles' => array('anonymous user', 'authenticated user'),
    );
    $permissions[] = array(
      'name' => 'view revisions',
      'roles' => array('anonymous user', 'authenticated user'),
    );
  }
  switch (variable_get('atrium_members', ATRIUM_MEMBERS_GROUP)) {
    case ATRIUM_MEMBERS_ALL:
      $permissions[] = array(
        'name' => 'view users outside groups',
        'roles' => array('anonymous user', 'authenticated user', 'manager', 'admin'),
      );
      break;
    case ATRIUM_MEMBERS_GROUP:
      $permissions[] = array(
        'name' => 'view users outside groups',
        'roles' => array('manager', 'admin'),
      );
      break;
  }

  return $permissions;
}

/**
 * Implementation of hook_init().
 */
function atrium_init() {
  // Alert the user that they are browsing an archived group.
  $space = spaces_get_space();
  if ($space && atrium_is_archived($space)) {
    $message = t('This !type is <strong>archived</strong>. You may not add or alter any of its content.', array('!type' => node_get_types('name', 'group')));
    if (node_access('update', $space->group)) {
      $message .= ' '. t('To reactivate this !type, !link.', array('!type' => node_get_types('name', 'group'), '!link' => l(t('click here'), "node/$space->id/reactivate")));
    }
    drupal_set_message($message);
  }
}

/**
 * Function that checks whether a group has been archived.
 */
function atrium_is_archived($space = NULL) {
  switch ($space->type) {
    case 'og':
      return !$space->group->status;
  }
  return FALSE;
}

/**
 * Implementation of hook_views_api().
 */
function atrium_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'atrium') .'/includes',
  );
}

/**
 * Implemenation of hook_nodeapi().
 */
function atrium_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch ($op) {
    case 'prepare':
    case 'view':
      // Confirm we are actually on a page of relevance
      if (menu_get_object() === $node) {
        // Set the context for the root book node type when on a book child page
        if (!empty($node->book['bid'])) {
          $type = db_result(db_query("SELECT type FROM {node} WHERE nid = %d", $node->book['bid']));

          // @TODO: Write a condition plugin for this rather than using nodeapi.
          if ($plugin = context_get_plugin('condition', 'node')) {
            $plugin->execute($node, 'view');
          }
        }
        // Display a message for archived content
        if ($op == 'view' && $node->status == 0) {
          $message = t('This !type is <strong>archived</strong>.', array('!type' => node_get_types('name', $node->type)));
          if (node_access('update', $node)) {
            $message .= ' '. t('To reactivate this !type, !link.', array('!type' => node_get_types('name', $node->type), '!link' => l(t('click here'), "node/{$node->nid}/reactivate")));
          }
          drupal_set_message($message);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_context_links_alter();
 */
function atrium_context_links_alter(&$links) {
  if (context_get('context', 'spaces-feature-book') && isset($links['book']) && $space = spaces_get_space()) {
    $item = menu_get_item('node/add/book');
    $node = menu_get_object();
    if ($item['access'] && !empty($node->book['mlid'])) {
      $links['book']['query'] = "parent={$node->book['mlid']}";
    }
  }
}

/**
 * Implementation of hook_menu().
 */
function atrium_menu() {
  $items = array();
  $items['welcome'] = array(
    'title' => 'Welcome',
    'description' => 'Custom login page.',
    'page callback' => 'atrium_welcome',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'atrium.pages.inc',
  );
  $items['help'] = array(
    'title' => 'Help',
    'description' => 'Information and help about using the site.',
    'page callback' => 'atrium_help_page',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'atrium.pages.inc',
  );
  $items['node/%node/reactivate'] = array(
    'title' => 'Reactivate',
    'description' => 'Reactivate confirmation for unpublished nodes.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('atrium_reactivate', 1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_menu_alter().
 */
function atrium_menu_alter(&$callbacks) {
  // Replace search callbacks
  if (module_exists('search')) {
    $unset = array('search', 'search/node/%menu_tail', 'search/user/%menu_tail');
    foreach ($unset as $path) {
      if (!empty($callbacks[$path])  && $callbacks[$path]['module'] == 'search') {
        unset($callbacks[$path]);
      }
    }
  }

  // Replace taxonomy autocomplete with our own space-aware autocomplete
  if (module_exists('taxonomy')) {
    $callbacks['taxonomy/autocomplete']['page callback'] = 'atrium_taxonomy_autocomplete';
    $callbacks['taxonomy/autocomplete']['module'] = 'atrium';
    $callbacks['taxonomy/autocomplete']['file'] = 'atrium.pages.inc';
  }

  // @TODO Replace user autocomplete with space-aware / "user access" aware autocomplete

  // Hijack the /node callback for use as our welcome page
  $callbacks['node']['page callback'] = 'drupal_goto';
  $callbacks['node']['page arguments'] = array('welcome');
}

/**
 * Implementation of hook_block().
 */
function atrium_block($op = 'list', $delta = 0) {
  switch ($op) {
    case 'list':
      $blocks = array();
      $blocks['book'] = array('info' => t('Atrium: Book'));
      return $blocks;
    case 'view':
      $function = "_atrium_block_{$delta}";
      if (function_exists($function)) {
        return call_user_func($function);
      }
      break;
  }
}

/**
 * Implementation of hook_form_alter().
 */
function atrium_form_alter(&$form, &$form_state, $form_id) {
  if ($form['#id'] == 'node-form') {
    $node = $form['#node'];

    // Book mods
    if ($form['#id'] == 'node-form' && book_type_is_allowed($form['#node']->type)) {
      $node = $form['#node'];

      if (!empty($form['book'])) {
        // Fieldset mods
        $form['book']['#weight'] = !empty($form['body_field']['#weight']) ? $form['body_field']['#weight'] : 0;
        $form['book']['#collapsible'] =
        $form['book']['#collapsed'] = FALSE;

        if (!empty($form['book']['bid']['#options'])) {
          // Remove "none" option -- do not allow book pages to be orphaned
          unset($form['book']['bid']['#options'][0]);
          // Filter book options by current space
          if ($view = views_get_view('atrium_book_current')) {
            $view->set_display();
            $view->set_items_per_page(0);
            $view->execute();

            // Collect books in this space into an array
            $books = array();
            $books[$node->nid] = 1;
            if (is_array($view->result) && count($view->result)) {
              foreach($view->result as $row) {
                $books[$row->nid] = 1;
              }
            }

            // Use collected array to filter options
            foreach ($form['book']['bid']['#options'] as $k => $v) {
              if (is_numeric($k) && !isset($books[$k])) {
                unset($form['book']['bid']['#options'][$k]);
              }
            }
          }
        }
      }
    }

    $space = spaces_get_space();

    // Determine whether this node is archivable
    $archivable = in_array($node->type, variable_get('atrium_archivable', array()));
    $archivable = !empty($node->nid) && $archivable;

    // Only allow root books to be archived.
    if (book_type_is_allowed($node->type)) {
      $archivable = $archivable && (!empty($node->book) && $node->book['plid'] == 0);
    }

    // Add a link to archive/reactive the space
    if ($archivable) {
      // Add archive / reactivate buttons
      if ($node->status) {
        $archive_help = t('This !type is currently <strong>active</strong>. You can archive it to hide it from listings and prevent others from adding to or altering its content. You can always undo this action by reactivating the !type.', array('!type' => node_get_types('name', $node->type)));
      }
      else {
        $archive_help = t('This !type is currently <strong>archived</strong>. You can reactivate it to allow others to add and alter its content.', array('!type' => node_get_types('name', $node->type)));
      }
      $form['archive'] = array(
        '#type' => 'fieldset',
        '#description' => $archive_help,
        '#weight' => 100,
      );
      $form['archive']['button'] = array(
        '#type' => 'submit',
        '#value' => $node->status ? t('Archive this !type', array('!type' => node_get_types('name', $node->type))) : t('Reactivate'),
        '#submit' => $node->status ? array('atrium_archive_submit') : array('atrium_reactivate_submit'),
      );
    }
    // Disable other node forms in archived spaces
    else if (atrium_is_archived($space)) {
      drupal_access_denied(); exit;
    }
  }
}

/**
 * Implementation of hook_form_alter for spaces_features_form.
 */
function atrium_form_spaces_features_form_alter(&$form, $form_state) {
  $space = spaces_get_space();
  if (!$space) {
    $form['atrium'] = array(
      '#type' => 'fieldset',
      '#title' => t('Site settings'),
      '#tree' => FALSE,
    );
    $form['atrium']['user_register'] = array(
      '#title' => t('Site mode'),
      '#type' => 'select',
      '#description' => t('Choose the access level for the site.'),
      '#options' => array(
        0 => t('Private access only'),
        1 => t('Public access, open registration'),
        2 => t('Public access, moderated registration'),
      ),
      '#default_value' => variable_get('user_register', 0),
    );
    $form['atrium']['atrium_members'] = array(
      '#title' => t('Members'),
      '#type' => 'select',
      '#description' => t('Choose the access mode for the member directory and profiles. Administrators and managers will be able to see all members regardless of this setting.'),
      '#options' => array(
        ATRIUM_MEMBERS_ALL=> t('Users can view all members'),
        ATRIUM_MEMBERS_GROUP => t('Users can only view members that belong to their groups')
      ),
      '#default_value' => variable_get('atrium_members', ATRIUM_MEMBERS_ALL),
    );
    $form['#submit'][] = 'atrium_form_spaces_features_form_submit';
  }
}

/**
 * Trigger a features rebuild.
 */
function atrium_form_spaces_features_form_submit(&$form, &$form_state) {
  features_rebuild();
}

/**
 * Implementation of hook_form_alter for system_themes_form.
 * Limit options to themes that implement atrium compatibility.
 */
function atrium_form_system_themes_form_alter(&$form, $form_state) {
  $themes = system_theme_data();
  foreach ($themes as $key => $theme) {
    if (empty($theme->info['atrium'])) {
      unset($form[$key]);
      unset($form['status']['#options'][$key]);
      unset($form['theme_default']['#options'][$key]);
    }
  }
}

/**
 *  Implementation of hook_form_alter for node_type_form.
 */
function atrium_form_node_type_form_alter(&$form, $form_state) {
  if (isset($form['identity']['type'])) {
    $form['atrium'] = array(
      '#type' => 'fieldset',
      '#title' => t('Atrium'),
      '#tree' => FALSE,
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,
    );
    $form['atrium']['atrium_update_type'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show in recent activity views'),
      '#description' => t('Show this content type in activity streams, update lists, etc.'),
      '#default_value' => variable_get('atrium_update_type_'. $form['#node_type']->type, TRUE),
    );
  }
}

/**
 * Form alter for views exposed forms.
 */
function atrium_form_views_exposed_form_alter(&$form, $form_state) {
  // Quick check that this is the right view
  $view = views_get_current_view();
  if ($view && $view->name === 'atrium_search' && !empty($form['created'])) {
    $options = array(
      '-14 days' => t('2 weeks ago'),
      '-30 days' => t('1 month ago'),
      '-180 days' => t('6 month ago'),
      '' => t('Anytime'),
    );
    $form['created']['#type'] = 'select';
    $form['created']['#options'] = $options;
    unset($form['created']['#size']);
  }
}

/**
 * OG archive submit handler.
 */
function atrium_archive_submit($form, &$form_state) {
  $nid = $form_state['values']['nid'];
  $node = node_load($nid);
  $node->status = 0;
  node_save($node);
  drupal_set_message(t('The @type @title has been archived.', array('@type' => node_get_types('name', $node->type), '@title' => $node->title)));
  $form_state['redirect'] = "node/{$node->nid}";
}

/**
 * Reactivate node submit handler.
 */
function atrium_reactivate_submit($form, &$form_state) {
  $nid = $form_state['values']['nid'];
  $node = node_load($nid);
  $node->status = 1;
  node_save($node);
  drupal_set_message(t('The @type @title has been reactivated.', array('@type' => node_get_types('name', $node->type), '@title' => $node->title)));
  $form_state['redirect'] = "node/{$node->nid}";
}

/**
 * Menu callback for reactivation confirmation form.
 */
function atrium_reactivate($form_state, $node) {
  $form = array();
  $form['nid'] = array('#type' => 'value', '#value' => $node->nid);
  $form['#submit'] = array('atrium_reactivate_submit');
  return confirm_form($form, t('Are you sure you want to reactivate %title?', array('%title' => $node->title)), "node/{$node->nid}", '', t('Reactivate'), t('Cancel'));
}

/**
 * Abstracts the node types provided in update streams/feed views.
 */
function atrium_update_types($reset = FALSE) {
  static $types;
  if (!isset($types) || $reset) {
    $types = array();
    foreach (array_keys(node_get_types()) as $type) {
      if (variable_get('atrium_update_type_'. $type, TRUE)) {
        $types[] = $type;
      }
    }
  }
  return $types;
}

/**
 * Wrapper access callback to provide access check against both a spaces
 * feature and an access perm.
 */
function atrium_feature_access($feature, $perm = 'access content') {
  return spaces_access_feature('view', $feature) && user_access($perm);
}

/**
 * BLOCKS =============================================================
 */

/**
 * Feature-aware book block.
 */
function _atrium_block_book() {
  context_set('atrium', 'book', 'rendering');

  $space = spaces_get_space();
  $block = array();
  if ($space) {
    if ($node = menu_get_object()) {
      $current_bid = empty($node->book['bid']) ? 0 : $node->book['bid'];
    }
    // Set customized title
    $features = spaces_features();
    $block['subject'] = t('Documents');

    // Generate book tree per book node in current space
    $output = '';
    if ($view = views_get_view('atrium_book_current')) {
      $view->set_display();
      $view->set_items_per_page(0);
      $view->execute();
      if (is_array($view->result) && count($view->result)) {
        foreach($view->result as $row) {
          $output .= menu_tree(book_menu_name($row->nid));
        }
      }
    }
    $block['content'] = $output;
  }

  context_set('atrium', 'book', FALSE);

  return $block;
}

/**
 * Search form.
 */
function atrium_search_form($form_state) {
  if (arg(0) == 'search' && isset($_GET['keys'])) {
    $default = urldecode($_GET['keys']);
  }
  $search = 
  $form = array();
  $form['search'] = array(
    '#type' => 'textfield',
    '#size' => 30,
    '#required' => true,
    '#default_value' => !empty($default) ? $default : '',
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
    '#submit' => array('atrium_search_form_submit'),
  );
  return $form;
}

/**
 * Search form submit handler.
 */
function atrium_search_form_submit($form, &$form_state) {
  $search = $form_state['values']['search'];
  drupal_goto('search', array('keys' => $search));
}

/**
 * Implementation of preprocess_views_view().
 */
function atrium_preprocess_views_view(&$vars) {
  $view = $vars['view'];
  $map = spaces_features_map();
  $feature = isset($map['views'][$view->name]) ? $map['views'][$view->name] : NULL;
  if ($feature && strpos($view->current_display, 'page') !== FALSE && empty($view->result) && empty($vars['empty'])) {
    if ($type = array_search($feature, $map['node'])) {
      $item = menu_get_item('node/add/'. strtr($type, array('_' => '-')));
      if ($item && $item['access']) {
        $output = t('Please add your first @type to get started.', array('@type' => node_get_types('name', $type)));
        $output .= "<div class='buttons'>". theme('links', context_links()) ."</div>";
      }
    }
    $vars['empty'] = !empty($output) ? $output : t('There is currently no content to view in this section.');
  }
}
